---
title: "HUMAN iPSC DERIVED MOTOR NEURONS AFTER 28 DAYS OF INDUCTION"

workflow adapted from:
Lun, A. M., DJ; Marioni, JC (2016). "A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor." F1000 Research 5(2122 ).
	
version authour:
- name: Regan Hamel
  affiliation: Department of Clinical Neurosciences, Cambridge Biosciences
Campus and NIHR Biomedical Research Centre, University of Cambridge
- name: Louise Thiry
  affiliation: Department of Neurology and Neurosurgery, Montreal Neurological Institute-Hospital,
McGill University

date: "`r Sys.Date()`"

---

##**INTRODUCTION**
Human induced pluripotent stem cells (iPSCs) offer the opportunity to generate specific cell types from healthy and diseased individuals, allowing the study of mechanisms of early human development, modelling a variety of human diseases, and facilitating the development of new therapeutics. Human iPSC-based applications are often limited by the variability among iPSC lines originating from a single donor, as well as the heterogeneity among specific cell types that can be derived from iPSCs. The ability to deeply phenotype different iPSC-derived cell types is therefore of primary importance to the successful and informative application of this technology. Here we describe a combination of motor neuron (MN) derivation and single-cell RNA sequencing approaches to generate and characterize specific MN subtypes obtained from human iPSCs. Our studies provide evidence for rapid and robust generation of MN progenitor cells that can give rise to a heterogenous population of brainstem and spinal cord MNs. Approximately 58% of human iPSC-derived MNs display molecular characteristics of lateral motor column MNs, ∼19% of induced MNs resemble hypaxial motor column MNs, while ∼6% of induced MNs have features of medial motor column MNs. The present study has the potential to improve our understanding of iPSC-derived MN subtype function and dysfunction, possibly leading to improved iPSC-based applications for the study of human MN biology and diseases.

##**1 INSTALLING BIOCONDUCTOR & PACKAGES**
 
```{r}
# Clear the workspace
rm(list = ls())

# Set the workspace
setwd("/Users/louise/Documents/R workflow")

# Install CRAN packages
install.packages("remotes")
install.packages("irlba")
install.packages("cowplot")
install.packages("Rtsne")
install.packages("igraph")
install.packages("gtools")
install.packages("pheatmap")
install.packages("ggplot2")

# Install DropletUtils (only available on the R development version, see https://github.com/MarioniLab/DropletUtils/issues/9) 
remotes::install_github("r-lib/remotes")
remotes::install_github("MarioniLab/DropletUtils")

# Download Bioconductor
if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")
BiocManager::install()

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("scater", version = "3.8")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("BiocFileCache", version = "3.8")

# Install gene symbols for humans: org.Hs.eg.db and EnsDb.Hsapiens.v86 
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("org.Hs.eg.db", version = "3.8")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("EnsDb.Hsapiens.v86", version = "3.8")

# Install tools and methods for making and manipulating transcript centric annotations
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("GenomicFeatures", version = "3.8")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("AnnotationDbi", version = "3.8")

# Install functions for low-level analyses of single-cell RNA-seq data. Methods are provided for normalization of cell-specific biases, assignment of cell cycle phase, detection of highly variable and significantly correlated genes, correction of batch effects, identification of marker genes," Aaron Lun
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("scran", version = "3.8")

# Install packages for data analysis, linear models and differential expression for microarray data.
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("limma", version = "3.8")

#Install utility functions for handling single-cell (RNA-seq) data from droplet technologies such as 10X Genomics.
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("DropletUtils", version = "3.9")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("EnsDb.Hsapiens.v86", version = "3.8")

#Install edgeR
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("edgeR") #To view documentation for the version of this package installed in your system, enter: browseVignettes("edgeR")

# Install goseq
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("goseq")

#Run and save session info
seshInfo <- sessionInfo()
```

##**2 READING IN A SPARSE MATRIX**

```{r}
# We load the 10X filtered data, creating a SingleCellExperiment (sce) object where each column corresponds to a cell barcode.
library(DropletUtils)
sce<- read10xCounts("/Users/louise/Documents/R workflow/control_D28/Filtered", col.names=TRUE)

# Each count represents the number of unique molecular identifiers (UMIs) assigned to a gene for a cell barcode.
class(counts(sce))
```

###2.1 Identify empty droplets
Based on barcode expression patterns, we identify cells as those with barcode patterns that differ from the ambient (loose, free-floating RNA) patterns
  "We use the emptyDrops() function to test whether the expression profile for each cell barcode is significantly different from the ambient RNA pool (Lun et al. 2018). Any significant deviation indicates that the barcode corresponds to a cell-containing droplet. We call cells at a false discovery rate (FDR) of 1% (e=0.01), meaning that no more than 1% of our called barcodes should be empty droplets on average."
  
```{r}
library(DropletUtils)
library(scater)
library(org.Mm.eg.db)
library(EnsDb.Hsapiens.v86) #For human gene symbols

set.seed(100)
e <- 0.01 #set the FDR value for empty drops
e.out <- emptyDrops(counts(sce))
sum(e.out$FDR <= e, na.rm=TRUE) 
  
#calculate the number of cells
#- gave ~14,000 cells post-FACS x2 + 3000 for HC = 31000 cells, with at 40% capture rate, we might expect around 12,400 cells
  
is.cell <- e.out$FDR <= e
sum(is.cell, na.rm=TRUE)
table(Limited=e.out$Limited, Significant=is.cell)
  
pdf(paste(dirI, "2.", sceL[1]," Diagnostic Plots.pdf", sep = "", collapes = ""))
plot(e.out$Total, -e.out$LogProb, col=ifelse(is.cell, "red", "black"),
       xlab="Total UMI count", ylab="-Log Probability")#, xlim = c(x1 = 0, x2 = 100))
  dev.off()
  
  
set.seed(100)
pdf(paste(dirI, "2.", sceL[1]," P Value Distribution.pdf", sep = "", collapes = ""))
limit <- 100   
all.out <- emptyDrops(counts(full.data), lower=limit, test.ambient=TRUE)
hist(all.out$PValue[all.out$Total <= limit & all.out$Total > 0],
      xlab="P-value", main="", col="grey80") 
dev.off()
  
  
#use the new filtered counts matrix from is.cell to create a filtered sce dataset
sce <- sce[,which(e.out$FDR <= e)]
  
#verify the number of cells in the new sce equals those that pass the threshold set above
ncol(sce) 
```

  
###2.2 Remove the effects of barcode swapping, based on: https://www.nature.com/articles/s41467-018-05083-x

```{r}
#load the molecul_info.h5 file
h5_file <-"/Users/louise/Documents/R workflow/control_D28/molecule_info.h5"

library(DropletUtils)

set.seed(1000)
s.out <- swappedDrops (h5_file, barcode.length=NULL, min.frac=0.9, get.swapped=TRUE, get.diagnostics=TRUE, hdf5.out=TRUE)
#"We do not recommend setting min.frac lower than 0.5"
length(s.out$cleaned)
class(s.out$cleaned[[1]])

```

##**3 ANNOTATING THE ROWS WITH GENE SYMBOLS**

```{r}
# This is done using the  uniquifyFeatureNames() function, which ensures uniqueness in the case of duplicated or missing symbols.
library(scater)
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ID, rowData(sce)$Symbol)
head(rownames(sce))

# Identifying raws with human gene symbols, as well as the chromosomal location for each gene. The mitochondrial location will be useful for later quality control.
library(EnsDb.Hsapiens.v86) #For human gene symbols
location <- mapIds(EnsDb.Hsapiens.v86, keys=rowData(sce)$ID, 
    column="SEQNAME", keytype="GENEID")
rowData(sce)$CHR <- location
summary(location=="MT") #TRUE = MT gene
```

###3.1 Saving the sce object to use in "Quality Control" or in "Keeping MNs only"

```{r}
save(sce, file="/Users/louise/Documents/R workflow/Objects/sce_1")
save(location, file="/Users/louise/Documents/R workflow/Objects/location_1")

# Clear the workspace
rm(list = ls())
```

##**4 QUALITY CONTROL**

```{r}
# Load previous object (if using the same dataset).
load("/Users/louise/Documents/R workflow/Objects/sce_1")
load("/Users/louise/Documents/R workflow/Objects/location_1")

```

###4.1 Quality control on the cells

```{r}
# We compute some QC metrics using  calculateQCMetrics() (McCarthy et al. 2017) and examine their distributions.
library(scater)
sce <- calculateQCMetrics(sce, feature=list(Mito=which(location=="MT")))

#total_counts ==== (library size) number of UMI counts for the cell (ie for each 10X barcode)
#total_features ==== (# of expressed genes) with expression above the detection limit (0)

#Examining the number of detected mRNAs per cell
hist(sce$total_counts/1e3, xlab="UMI Counts (thousands)", breaks=20, col="grey80",
     ylab="Number of cells", main = "Number of Detected Transcripts per Cell")
dev.off()

#Examining the number of detected genes per cell
hist(sce$total_features_by_counts/1e3, breaks=20, col="grey80",
    xlab="Number of Expressed Genes (thousands)", main = "Number of Detected Genes per Cell", ylab="Number of cells")
dev.off()

#Examining the proportion of mitochondrial to nuclear DNA
hist(sce$pct_counts_Mito/1e3, breaks=20, col="grey80",
    xlab="Proportion of Reads That Are Mitochondrial Genes", ylab="Number of cells", main = "Mitochondrial Genes per Cell")
dev.off()
```

###4.2 Removing cells with low library sizes or total number of expressed features, likely corresponding to damaged cells or ambiant RNA

```{r}
libsize.drop <- isOutlier(sce$total_counts, nmads=2, type="lower", log=TRUE)
feature.drop <- isOutlier(sce$total_features_by_counts, nmads=2, type="lower", log=TRUE)

sce <- sce[,!(libsize.drop | feature.drop )]

# Number of cells removed by each filter, and number of remaining cells after QC
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop), Remaining=ncol(sce), row.names = "# of cells")
```

###4.3 Removing cells with large mitochondrial proportions, using it as a proxy for cell damage

```{r}
#Note that if you run this more than once, the number of true accounts change because you've removed the original batch, changing the proportions --- so make sure you only run it on the sce once.
high.mito <- isOutlier(sce$pct_counts_Mito, nmads=3, type="higher")
sce <- sce[,!high.mito]
summary(high.mito) #True = number of cells excluded because of large mitochondrial RNA to cytoplasmic RNA levels
```

###4.4 Median values for number of detected reads/cell, number of detected genes/cell and proportion of MT RNA/cell
```{r}
#Examining the number of detected mRNAs per cell
DetectedReads.median <- median(sce$total_counts)

#Examining the number of detected genes per cell
DetectedGenes.median <- median(sce$total_features_by_counts)
DetectedGenes.min <- min(sce$total_features_by_counts)

#Examining the proportion of mitochondrial to nuclear DNA
MTproportion.median <- median(sce$pct_counts_Mito)

#Print
DetectedReads.median
DetectedGenes.median
MTproportion.median
DetectedGenes.min
```

##**5 NORMALIZATION** 

###5.1 Filtering out low-abundance genes
This is done by calculating the average counts across all cells
"Low-abundance genes are problematic because 0 or near-zero counts do not contain enough information for reliable statistical inference (Bourgon et al, 2010). In addition, the discreteness of the counts may interfere with downstream statistical procedures by compromising the accuracy of continuous approximations. Here, low-abundance genes are defined as those with an average count below a filter threshold of 1. These genes are likely to be dominated by drop-out events (Brennecke et al, 2013), which limits their usefulness in later analyses." (Lun et al. 2019)

```{r}
ave.counts <- calcAverage(sce)
to.keep <- ave.counts > 0
sce <- sce[to.keep,]
summary(to.keep) # TRUE = number of genes remaining
```

###5.2 Examining gene expression

```{r}
#"To check whether the chosen threshold is suitable, we examine the distribution of log-means across all genes. The peak represents the bulk of moderately expressed genes while the rectangular component corresponds to lowly expressed genes. The filter threshold should cut the distribution at some point along the rectangular component to remove the majority of low-abundance genes."
ave <- calcAverage(sce)
rowData(sce)$AveCount <- ave
hist(log10(ave), breaks=100, main="", col="grey80",
     xlab=expression(Log[10]~"average count"))
abline(v=log10(1), col="blue", lwd=2, lty=2)
```

###5.3 Plot the most highly expressed genes

```{r}
#Examining the most highly expressed genes. These should be dominated by ribosomal protein and mitochondrial genes. "For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle represents the average across all cells. Bars are coloured by the total number of expressed features in each cell." (Lun et al. 2019)
library(ggplot2)
library(scater)
plotHighestExprs(sce) + ggtitle("HighestExpressedGenes")
```

###5.4 Normalizing for cell-specific biases
Cell-specific biases such as differences in capture efficiency and sequencing depth between cells

```{r}
# We apply the deconvolution method to compute size factors for all cells (Lun, Bach, and Marioni 2016 https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0947-7). 
library(scran)
library(irlba)
set.seed(1000)
clusters <- quickCluster(sce, method="igraph", min.mean=0.1,
    irlba.args=list(maxit=1000))
table(clusters)
```

```{r}
sce <- computeSumFactors(sce, min.mean=0.1, cluster=clusters)
summary(sizeFactors(sce))
```

###5.5 Comparing the above size factors to their library size

```{r}
plot(sizeFactors(sce), sce$total_counts, log="xy", ylab ="UMI Counts Per Cell", xlab = "Size Factor")
dev.off() # A tight linear correlation suggests that the systematic differences between cells are primarily driven by differences in capture efficiency or sequencing depth. Any differential expression between cells would yield a non-linear trend between the total count and size factor, and/or increased scatter around the trend.
```

###5.6 Normalizing each gene based on the size factor

```{r}
sce <- normalize(sce) # We compute normalized log-expresion values.
```

###5.7 Saving the sce object after Quality Control to avoid re-running the above code

```{r}
save(sce, file = "/Users/louise/Documents/R workflow/Objects/sce_postQC")

# Clear the workspace
rm(list = ls())
```

##**6 MODELLING VARIANCE & DENOISING**

```{r}
# Load previous object (if using the same dataset).
load("/Users/louise/Documents/R workflow/Objects/sce_postQC")
```

###6.1 Modelling the mean-variance trend

```{r}
# For a heterogenous population, we assume that the technical noise is Poisson and create a fitted trend on that basis using the makeTechTrend() function. (Lun et al. 2019)
library(scran)
new.trend <- makeTechTrend(x=sce)

# The Poisson-based trend serves as a lower bound for the variances of the endogenous genes, consistent with non-zero biological components. (Lun et al. 2019)
fit <- trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))

# Looking at the variation of the genes compared to the quantity of their expression.
plot(fit$mean, fit$var, pch=20, ylab = "Variance of Log-Expression", xlab = "Mean Log-Expression", main = "Variance of Gene Log-Expression Values" )
curve(fit$trend(x), col="dodgerblue", add=TRUE)
curve(new.trend(x), col="red", add=TRUE) # The blue line represents the mean-dependent trend fitted to the variances, while the red line represents the Poisson (technical) noise.

```

###6.2 Examining the genes with the highest biological components

```{r}
fit$trend <- new.trend
dec <- decomposeVar(fit=fit)
top.dec <- dec[order(dec$bio, decreasing=TRUE),] 
head(top.dec)
```

###6.3 Violin plot of the genes with the largest biological components
Looking at the distribution of expression values for the top HVGs to ensure that the variance estimate is not being dominated by one or two outlier cells.
```{r}
library(scater)
plotExpression(sce, features=rownames(top.dec)[1:10])
```

###6.4 Saving the sce object after Normalization to avoid re-running the above code

```{r}
save(new.trend, file = "/Users/louise/Documents/R workflow/Objects/new.trend")

# Clear the workspace
rm(list = ls())
```

##**7 DIMENSIONALITY REDUCTION**

```{r}
# Load previous objects (if using the same dataset).
load("/Users/louise/Documents/R workflow/Objects/sce_postQC")
load("/Users/louise/Documents/R workflow/Objects/new.trend")
```

###7.1 Removing the principal components corresponding to technical noise
Principal component = PC

```{r}
library(scran)
library(scater)

# Set seed to allow replicability
set.seed(1000)

# Save the sce after using PCA to regress out technical noise
sce <- denoisePCA(sce, technical=new.trend, approx=TRUE)

# Updating the sce object with the PC scores for each cell in the reducedDims slot
ncol(reducedDim(sce, "PCA"))

# PCA plot of the first few components (can change the amounts by using ncomponents) to visualize the relationships between cells. Each point represents a cell, coloured according to its total number of expressed features (ie number of expressed genes). Bars represent the coordinates of the cells on each axis.
plot(attr(reducedDim(sce), "percentVar"), xlab="PC",
    ylab="Proportion of variance explained")
abline(v=ncol(reducedDim(sce, "PCA")), lty=2, col="red") # The red line represents the chosen number of principle components
dev.off()
```

###7.2 Examining the first few PCs

```{r}
#Note: outliers on a PCA plot may be indicative of low-quality cells that have aberrant technical properties compared to the (presumed) majority of high-quality cells.
plotPCA(sce, ncomponents=3)
```

###7.3 Visualizing data with a t-SNE plot

```{r}
# Again, note that we set use_dimred= to perform t-SNE on the denoised expression matrix.
# Comparing the t-SNE plots obtained with Perplexity=30, 40 or 50
set.seed(100)
runTSNE(sce, use_dimred="PCA", perplexity=30, set.seed=100) 
tSNE30 <- plotTSNE(sce) + ggtitle ("Perplexity = 30")

set.seed(100)
runTSNE(sce, use_dimred="PCA", perplexity=40, set.seed=100) 
tSNE40 <- plotTSNE(sce) + ggtitle ("Perplexity = 40")

set.seed(100)
runTSNE(sce, use_dimred="PCA", perplexity=50, set.seed=100) 
tSNE50 <- plotTSNE(sce) + ggtitle ("Perplexity = 50")

multiplot(tSNE30, tSNE40, tSNE50, cols=3) # Each point represents a cell and is coloured according to the log-number of expressed features.
```

###7.4 Running the t-SNE with the appropriate perplexity and saving the updated sce object

```{r}
sce <- runTSNE(sce, use_dimred="PCA", perplexity=40, rand_seed=NULL) 

# Save the updated sce object
save(sce, file = "/Users/louise/Documents/R workflow/Objects/sce_dimred")

plotTSNE(sce) + ggtitle ("t-SNE, Perplexity = 40")
```

```{r}
# Clear the workspace
rm(list = ls())
```

##**8 CLUSTERING WITH GRAPH-BASED METHODS**

```{r}
# Load previous objects (if using the same dataset)
library(scran)
library(scater)
load("/Users/louise/Documents/R workflow/Objects/sce_dimred")

# Build a shared nearest neighbour (SNN) graph (Xu and Su 2015) and use the Walktrap algorithm to identify clusters
set.seed(1000)
snn.gr <- buildSNNGraph(sce, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr, steps = 7)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)
```

###8.1 Examining the clusters separation

```{r}
# We look at the ratio of the observed and expected edge weights to confirm that the clusters are modular. To visualize this, we construct a heatmap of the log10-ratio of the total weight between nodes in the same cluster or in different clusters, relative to the total weight (vs) expected under a null model of random links.
library(pheatmap)
cluster.mod <- clusterModularity(snn.gr, sce$Cluster, get.values=TRUE)
log.ratio <- log2(cluster.mod$observed/cluster.mod$expected + 1)
pheatmap(log.ratio, cluster_rows=FALSE, cluster_cols=FALSE, 
     color=colorRampPalette(c("white", "blue"))(100), main = "Heatmap Showing Cluster Separation") # This heatmap indicates that most of the clusters are well seperated, with few strong off-diagonal entries.
```

###8.2 Examining the cluster identities on a t-SNE plot, to confirm that different clusters are indeed separated

```{r}
plotTSNE(sce, colour_by="Cluster") +  ggtitle("t-SNE by Cluster, Perplexity = 40") # Each point represents a cell and is coloured according to its cluster identity.
```

###8.3 Saving the sce object after Clustering to avoid re-running the above code

```{r}
save(sce, file = "/Users/louise/Documents/R workflow/Objects/sce_clusters")
```

##**9 IDENTIFYING SUB-POPULATIONS IN THE DATA SET**

```{r}
#Count Motor Neurons (MNs) and Motor Neuron Progenitor Cells (MNPCs), identified by the expression of CHAT, ISL1, ISL2, MNX1, OLIG2, NEUROG2
sce$is.MN <- counts(sce)["CHAT", ]>0 | counts(sce)["ISL1", ]>0 | counts(sce)["ISL2", ]>0 | counts(sce)["MNX1", ]>0 | counts(sce)["OLIG2", ]>0 | counts(sce)["NEUROG2", ]>0

# Count Interneurons (INs), identified by the expression of PAX3, VSX2, GATA3, SOX14, SIM1, LBX1, TLX3; and lack of expression of MNX1, OLIG2, CHAT, ISL1, ISL2, NEUROG2
sce$is.IN <- counts(sce)["PAX3",] >=1 | counts(sce)["VSX2",] >=1 | counts(sce)["GATA3",] >=1 | counts(sce)["SOX14",] >=1 | counts(sce)["SIM1",] >=1 | counts(sce)["LBX1",] >=1 & counts(sce)["TLX3",] >=1 & counts(sce)["MNX1",] <=0 & counts(sce)["OLIG2",] <=0 & counts(sce)["CHAT",] <=0 & counts(sce)["ISL1",] <=0 & counts(sce)["ISL2",] <=0 & counts(sce)["NEUROG2",] <=0

# Count Neural Progenitor Cells (NPCs), identified by the expression of SOX1, SOX2, MKI67
sce$is.NPC <- counts(sce)["SOX1",] >=1 | counts(sce)["SOX2",] >=1 & counts(sce)["MKI67",] >=1 

# Count Glial Cells, identified by the expression of SOX9, S100B, GFAP
sce$is.Glia <- counts(sce)["SOX9",] > 0 | counts(sce)["S100B",] > 0 #Absence of GFAP+ cell

# Count Oligodendrocytes, identified by the expression of PDFRA, GALC
sce$is.OL <- counts(sce)["PDGFRA",] > 0 | counts(sce)["GALC",] > 0

# Count undifferentiated cells (iPSCs), identified by the expression of NANOG, OCT4 (=POU5F1)
sce$is.iPSC <- counts(sce)["NANOG", ]>0 | counts(sce)["POU5F1", ]>0

# Print the number of cells in each sub-population
sum(sce$is.MN)
sum(sce$is.IN)
sum(sce$is.NPC)
sum(sce$is.Glia)
sum(sce$is.OL)
sum(sce$is.iPSC)

```

###9.1 Colouring the t-SNE plot for MNs and MNPCs

```{r}
plotTSNE(sce, colour_by = "is.MN") +  ggtitle("t-SNE MNs and MNPCs, Perplexity = 40")
```

###9.2 Looking at other cell types potentially present in the data set

```{r}
# Count cells of the endodermal lineage, identified by the expression of GATA4
sce$is.endoderm <- counts(sce)["GATA4", ]>0

# Count cells of the esodermal lineage, identified by the expression of TBXT
sce$is.mesoderm <- counts(sce)["TBXT", ]>0 #There is none in the data set

# Count cells of the anterior structures lineage, identified by the expression of FOXG1
sce$is.FOXG1 <- counts(sce)["FOXG1", ]>0 #There is none in the data set

#Print
sum(sce$is.endoderm)
sum(sce$is.mesoderm)
sum(sce$is.FOXG1)

```

###9.3 Counting the number of cells per cluster, for each identified sub-population

```{r}
# Defining genes for MNs and MNPCs identification
gene1 <- "CHAT"
gene2 <- "ISL1"
gene3 <- "ISL2"
gene4 <- "MNX1"
gene5 <- "OLIG2"
gene6 <- "NEUROG2"

# Defining genes for INs identification
gene7 <- "PAX2"
gene8 <- "PAX3"
gene9 <- "VSX2"
gene10 <- "GATA3"
gene11 <- "SOX14"
gene12 <- "SIM1"
gene13 <- "LBX1"
gene14 <- "TLX3"

# Defining genes for Glia identification
gene15 <- "S100B"
gene16 <- "SOX9"

# Defining genes for Oligodndrocytes (OL) identification 
gene17 <- "PDGFRA"
gene18 <- "GALC"

#NPCs
gene19 <-"SOX1"
gene20 <- "SOX2"
gene21 <-"MKI67"

#iPSCs
gene22 <-"NANOG"
gene23 <- "POU5F1"


#Create a boolean list of cells expressing the gene of interest

MN <- counts(sce)[gene1, ]>0 | counts(sce)[gene2, ]>0 | counts(sce)[gene3, ]>0 | counts(sce)[gene4, ]>0 | counts(sce)[gene5, ]>0 | counts(sce)[gene6, ]>0

NPC <- counts(sce)[gene15,] <0 & counts(sce)[gene16,] <0 & counts(sce)[gene17,] <0 & counts(sce)[gene18,] <0 & counts(sce)[gene19,]<0 & counts(sce)[gene20,]<0 & counts(sce)[gene21,]<0 & counts(sce)[gene1, ]<0 & counts(sce)[gene2, ]<0 & counts(sce)[gene3, ]<0 & counts(sce)[gene4, ]<0 & counts(sce)[gene7,] <0 & counts(sce)[gene8,] <0 & counts(sce)[gene9,] <0 & counts(sce)[gene10,] <0 & counts(sce)[gene11,] <0 & counts(sce)[gene12,] <0 & counts(sce)[gene13,] <0 & counts(sce)[gene14,] <0 & counts(sce)[gene19,] >0 | counts(sce)[gene20,] >0 | counts(sce)[gene21,] >0

Glia <-  counts(sce)[gene17,] <0 & counts(sce)[gene18,] <0 & counts(sce)[gene19,]<0 & counts(sce)[gene20,]<0 & counts(sce)[gene21,]<0 & counts(sce)[gene1, ]<0 & counts(sce)[gene2, ]<0 & counts(sce)[gene3, ]<0 & counts(sce)[gene4, ]<0 & counts(sce)[gene5, ]<0 & counts(sce)[gene6, ]<0 & counts(sce)[gene15,] >0 | counts(sce)[gene16,] >0

OL <-  counts(sce)[gene15,] <0 & counts(sce)[gene16,] <0 & counts(sce)[gene19,]<0 & counts(sce)[gene20,]<0 & counts(sce)[gene21,]<0 & counts(sce)[gene1, ]<0 & counts(sce)[gene2, ]<0 & counts(sce)[gene3, ]<0 & counts(sce)[gene4, ]<0 & counts(sce)[gene5, ]<0 & counts(sce)[gene6, ]<0 & counts(sce)[gene17,] >0 | counts(sce)[gene18,] >0

IN <- MN == FALSE & NPC == FALSE & Glia == FALSE & OL == FALSE & counts(sce)[gene7,] >0 | counts(sce)[gene8,] >0 | counts(sce)[gene9,] >0 | counts(sce)[gene10,] >0 | counts(sce)[gene11,] >0 | counts(sce)[gene12,] >0 | counts(sce)[gene13,] >0 & counts(sce)[gene14,] >0

iPSC <- counts(sce)[gene22, ]>0 | counts(sce)[gene23, ]>0

#Remove cells without the gene
haveMN <- sce[ ,MN]
haveIN <- sce[ ,IN]
haveGlia <- sce[ ,Glia]
haveOL <- sce[ ,OL]
haveNPC <- sce[ ,NPC]
haveiPSC <- sce[ ,iPSC]

#Print the number of cells expressing the gene of interest in eah cluster
summary(haveiPSC$Cluster)
summary(haveNPC$Cluster)
summary(haveMN$Cluster)
summary(haveIN$Cluster)
summary(haveGlia$Cluster)
summary(haveOL$Cluster)

#Print the total number of cells in each cluster
summary(sce$Cluster)
```

```{r}
# Clear the workspace
rm(list = ls())
```

##**10 KEEPING ONLY MNPCs AND MNs IN THE DATASET**

```{r}
library(scater)
# Load previous object (if using the same dataset).
load("/Users/louise/Documents/R workflow/Objects/sce_1")
load("/Users/louise/Documents/R workflow/Objects/location_1")

# Defining the genes of interest
gene1 <- "CHAT"
gene2 <- "ISL1"
gene3 <- "ISL2"
gene4 <- "MNX1"
gene5 <- "OLIG2"
gene6 <- "NEUROG2"

# Store all the MNPs and MNs (= identified as cells expressing CHAT, ISL1, ISL2, MNX1, OLIG2, NEUROG2) in an object
keep <- counts(sce)[gene1, ]>0 | counts(sce)[gene2, ]>0 | counts(sce)[gene3, ]>0 | counts(sce)[gene4, ]>0 | counts(sce)[gene5, ]>0 | counts(sce)[gene6, ]>0

#create a copy of the sce that contains only the cells in the previous object
sce.MN <- sce[,keep]

#print a summary of the new sce object
sce.MN
```

###10.1 Saving the sce.MN object to use in "Quality Control" or in "Keeping LMC MNs only"

```{r}
save(sce.MN, file="/Users/louise/Documents/R workflow/Objects/sce.MN")
save(location, file="/Users/louise/Documents/R workflow/Objects/location_sce.MN")

# Clear the workspace
rm(list = ls())
```

##**11 QUALITY CONTROL ON THE NEW sce.MN OBJECT**

```{r}
# Remove the effects of barcode swapping - updated Jan 24, 2019
library(DropletUtils)
set.seed(1000)
s.out <- swappedDrops (sce.MN, barcode.length=NULL, min.frac=0.9, get.swapped=FALSE, get.diagnostics=FALSE, hdf5.out=TRUE)
length(s.out$cleaned)
class(s.out$cleaned[[1]])
```

###11.1 Quality control on the cells

```{r}
# We compute some QC metrics using calculateQCMetrics() (McCarthy et al. 2017) and examine their distributions.
library(scater)
sce.MN <- calculateQCMetrics(sce.MN, feature_controls=list(Mito=which(location=="MT")))

#Examining the number of detected mRNAs per cell
hist(sce.MN$total_counts/1e3, xlab="UMI Counts (thousands)", breaks=20, col="grey80",
     ylab="Number of cells", main = "Number of Detected Transcripts per Cell")
dev.off()

#Examining the number of detected genes per cell
hist(sce.MN$total_features_by_counts/1e3, breaks=20, col="grey80",
    xlab="Number of Expressed Genes (thousands)", main = "Number of Detected Genes per Cell", ylab="Number of cells")
dev.off()

#Examining the proportion of mitochondrial to nuclear DNA
hist(sce.MN$pct_counts_Mito, breaks=20, col="grey80",
    xlab="Proportion of Reads That Are Mitochondrial Genes", 
    ylab="Number of cells", main = "Mitochondrial Genes per Cell")
dev.off()
```

###11.2 Removing cells with low library sizes or total number of expressed features
These cells likely corresponding to damaged cells or ambiant RNA.

```{r}
libsize.drop <- isOutlier(sce.MN$total_counts, nmads=3, type="lower", log=TRUE)
feature.drop <- isOutlier(sce.MN$total_features_by_counts, nmads=3, type="lower", log=TRUE)

sce.MN <- sce.MN[,!(libsize.drop | feature.drop )]

# Number of cells removed by each filter, and number of remaining cells after QC
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop), Remaining=ncol(sce.MN), row.names = "# of cells")
```

###11.3 Removing cells with large mitochondrial proportions, using it as a proxy for cell damage.

```{r}
#Note that if you run this more than once, the number of true accounts change because you've removed the original batch, changing the proportions --- so make sure you only run it on the sce once.
high.mito <- isOutlier(sce.MN$pct_counts_Mito, nmads=3, type="higher")
sce.MN<- sce.MN[,!high.mito]
summary(high.mito) #True = number of cells excluded because of large mitochondrial RNA to cytoplasmic RNA levels
```

###11.4 Median values for number of detected reads/cell, number of detected genes/cell and proportion of MT RNA/cell

```{r}
# Examining the number of detected mRNAs per cell
DetectedReads.median <- median(sce.MN$total_counts)

# Examining the number of detected genes per cell
DetectedGenes.median <- median(sce.MN$total_features_by_counts)
DetectedGenes.min <- min(sce.MN$total_features_by_counts)

# Examining the proportion of mitochondrial to nuclear DNA
MTproportion.median <- median(sce.MN$pct_counts_Mito)

# Print
DetectedReads.median
DetectedGenes.median
MTproportion.median

DetectedGenes.min
```

##**12 NORMALIZATION ON THE NEW sce.MN OBJECT**

###12.1 Filtering out low-abundance genes
This is done by calculating the average counts across all cells.

```{r}
ave.counts <- calcAverage(sce.MN)
to.keep <- ave.counts > 0
sce.MN <- sce.MN[to.keep,]
summary(to.keep)
```

###12.2 Examining gene expression

```{r}
ave <- calcAverage(sce.MN)
rowData(sce.MN)$AveCount <- ave
hist(log10(ave), breaks=100, main="", col="grey80",
     xlab=expression(Log[10]~"average count"))
abline(v=log10(1), col="blue", lwd=2, lty=2)
```

###12.3 Plot the most highly expressed genes

```{r}
library(ggplot2)
library(scater)
plotHighestExprs(sce.MN) + ggtitle("HighestExpressedGenes")
```

###12.4 Normalizing for cell-specific biases
Cell-specific biases such as differences in capture efficiency and sequencing depth between cells.

```{r}
library(scran)
library(irlba)
set.seed(1000)
clusters <- quickCluster(sce.MN, method="igraph", min.mean=0.1,
    irlba.args=list(maxit=1000))
table(clusters)
```

```{r}
sce.MN <- computeSumFactors(sce.MN, min.mean=0.1, cluster=clusters)
summary(sizeFactors(sce.MN))
```

###12.5 Comparing the above size factors to their library size

```{r}
pdf("/Users/louise/Documents/R workflow/ToSave/MN_Size factors vs UMI counts.pdf")
plot(sizeFactors(sce.MN), sce.MN$total_counts, log="xy", ylab ="UMI Counts Per Cell", xlab = "Size Factor")
dev.off()
```

###12.6 Normalizing each gene based on the size factor

```{r}
sce.MN <- normalize(sce.MN) # We compute normalized log-expresion values.
```

###12.7 Saving the sce.MN object after Quality Control to avoid re-running the above code

```{r}
save(sce.MN, file = "/Users/louise/Documents/R workflow/Objects/sce.MN_postQC")

# Clear the workspace
rm(list = ls())
```

##**13 MODELLING VARIANCE & DENOISING ON THE NEW sce.MN OBJECT**

```{r}
# Load previous object (if using the same dataset).
load("/Users/louise/Documents/R workflow/Objects/sce.MN_postQC")
```

###13.1 Modelling the mean-variance trend

```{r}
# For a heterogenous population, we assume that the technical noise is Poisson and create a fitted trend on that basis using the makeTechTrend() function. (Lun et al. 2019)
library(scran)
new.trend <- makeTechTrend(x=sce.MN)

# The Poisson-based trend serves as a lower bound for the variances of the endogenous genes, consistent with non-zero biological components. (Lun et al. 2019)
fit <- trendVar(sce.MN, use.spikes=FALSE, loess.args=list(span=0.05))

# Looking at the variation of the genes compared to the quantity of their expression.
plot(fit$mean, fit$var, pch=20, ylab = "Variance of Log-Expression", xlab = "Mean Log-Expression", main = "Variance of Gene Log-Expression Values" )
curve(fit$trend(x), col="dodgerblue", add=TRUE)
curve(new.trend(x), col="red", add=TRUE) # The blue line represents the mean-dependent trend fitted to the variances, while the red line represents the Poisson (technical) noise.

```

###13.2 Examining the genes with the highest biological components

```{r}
fit$trend <- new.trend
dec <- decomposeVar(fit=fit)
top.dec <- dec[order(dec$bio, decreasing=TRUE),] 
head(top.dec)
```

###13.3 Violin plot of the genes with the largest biological components
Looking at the distribution of expression values for the top HVGs to ensure that the variance estimate is not being dominated by one or two outlier cells.
```{r}
library(scater)
plotExpression(sce.MN, features=rownames(top.dec)[1:10])
```

###13.4 Saving the sce.MN object after Normalization to avoid re-running the above code

```{r}
save(new.trend, file = "/Users/louise/Documents/R workflow/Objects/sce.MN_new.trend")

# Clear the workspace
rm(list = ls())
```

##**14 DIMENSIONALITY REDUCTION ON THE NEW sce.MN OBJECT**

```{r}
# Load previous objects (if using the same dataset).
load("/Users/louise/Documents/R workflow/Objects/sce.MN_postQC")
load("/Users/louise/Documents/R workflow/Objects/sce.MN_new.trend")
```

###14.1 Removing the PCs corresponding to technical noise

```{r}
library(scran)
library(scater)

# Set seed to allow replicability
set.seed(100)

# Save the sce after using PCA to regress out technical noise
sce.MN <- denoisePCA(sce.MN, technical=new.trend, approx=TRUE)
save(sce.MN, file = "/Users/louise/Documents/R workflow/Objects/sce.MN_denoised")

# Updating the sce object with the PC scores for each cell in the reducedDims slot
ncol(reducedDim(sce.MN, "PCA"))

# PCA plot of the first few components (can change the amounts by using ncomponents) to visualize the relationships between cells. Each point represents a cell, coloured according to its total number of expressed features (ie number of expressed genes). Bars represent the coordinates of the cells on each axis.
plot(attr(reducedDim(sce.MN), "percentVar"), xlab="PC",
    ylab="Proportion of variance explained")
abline(v=ncol(reducedDim(sce.MN, "PCA")), lty=2, col="red") 
dev.off() # The red line represents the chosen number of principle components
```

###14.2 Examining the first few PCs

```{r}
#Note: outliers on a PCA plot may be indicative of low-quality cells that have aberrant technical properties compared to the (presumed) majority of high-quality cells.
plotPCA(sce.MN, ncomponents=3)
```

###14.3 Visualizing data with a t-SNE plot

```{r}
# Again, note that we set use_dimred= to perform t-SNE on the denoised expression matrix.
# Comparing the t-SNE plots obtained with Perplexity=30, 40 or 50
set.seed(100)
runTSNE(sce.MN, use_dimred="PCA", perplexity=30, set.seed=100) 
tSNE30 <- plotTSNE(sce.MN) + ggtitle ("Perplexity = 30")

set.seed(100)
runTSNE(sce.MN, use_dimred="PCA", perplexity=40, set.seed=100) 
tSNE40 <- plotTSNE(sce.MN) + ggtitle ("Perplexity = 40")

set.seed(100)
runTSNE(sce.MN, use_dimred="PCA", perplexity=50, set.seed=100) 
tSNE50 <- plotTSNE(sce.MN) + ggtitle ("Perplexity = 50")

multiplot(tSNE30, tSNE40, tSNE50, cols=3) # Each point represents a cell and is coloured according to the log-number of expressed features.
```

###14.4 Running the t-SNE with the appropriate perplexity and saving the updated sce.MN object

```{r}
sce.MN <- runTSNE(sce.MN, use_dimred="PCA", perplexity=40, set.seed=100) 

# Save the updated sce object
save(sce.MN, file = "/Users/louise/Documents/R workflow/Objects/sce.MN_dimred")

plotTSNE(sce.MN) + ggtitle ("t-SNE, Perplexity = 40")
```

```{r}
# Clear the workspace
rm(list = ls())
```

##**15 CLUSTERING WITH GRAPH-BASED METHODS ON THE NEW sce.MN OBJECT**

```{r}
# Load previous objects (if using the same dataset)
library(scran)
library(scater)
load("/Users/louise/Documents/R workflow/Objects/sce.MN_dimred")

# Build a shared nearest neighbour (SNN) graph (Xu and Su 2015) and use the Walktrap algorithm to identify clusters
set.seed(1000)
snn.gr <- buildSNNGraph(sce.MN, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr, steps = 8)
sce.MN$Cluster <- factor(clusters$membership)
table(sce.MN$Cluster)
```

###15.1 Examining the clusters separation

```{r}
library(pheatmap)
cluster.mod <- clusterModularity(snn.gr, sce.MN$Cluster, get.values=TRUE)
log.ratio <- log2(cluster.mod$observed/cluster.mod$expected + 1)
pheatmap(log.ratio, cluster_rows=FALSE, cluster_cols=FALSE, 
     color=colorRampPalette(c("white", "blue"))(100), main = "Heatmap Showing Cluster Separation") # This heatmap indicates that most of the clusters are well seperated, with few strong off-diagonal entries.
```

###15.2 Examining the cluster identities on a t-SNE plot, to confirm that different clusters are indeed separated

```{r}
plotTSNE(sce.MN, colour_by="Cluster") +  ggtitle("t-SNE -MN only- by Cluster, Perplexity = 40") # Each point represents a cell and is coloured according to its cluster identity.
```

###15.3 Saving the sce.MN object after Clustering to avoid re-running the above code

```{r}
save(sce.MN, file = "/Users/louise/Documents/R workflow/Objects/sce.MN_clusters")
load("/Users/louise/Documents/R workflow/Objects/sce.MN_clusters")
```

##**16 IDENTIFYING MNs SUBPOPULATIONS**

###16.1 Colouring the t-SNE plot for LMC MNs
LMC MNs are cells identified as LHX3- FOXP1+
```{r}
sce.MN$LMC <- counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",] >=1
plotTSNE(sce.MN, colour_by = "LMC") +  ggtitle("tSNE-LMC MNs, Perplexity = 40") 
```

###16.2 Colouring the t-SNE plot for MMC MNs
MMC MNs are cells identified as LHX3+ FOXP1-

```{r}
sce.MN$MMC <- counts(sce.MN)["LHX3",] >=1 & counts(sce.MN)["FOXP1",] <1
plotTSNE(sce.MN, colour_by = "MMC") +  ggtitle("tSNE-MMC MNs, Perplexity = 40") 
```

###16.3 Colouring the t-SNE plot for cervical HMC MNs
HMC MNs are cells identified as LHX3- FOXP1- HOXA5+

```{r}
sce.MN$HMC <- counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",] <1 & counts(sce.MN)["HOXA5",] >=1
plotTSNE(sce.MN, colour_by = "HMC") +  ggtitle("tSNE-HMC MNs (LHX3-FOXP1-HOXA5+), Perplexity = 40") 
```

###16.4 Counting the number of cells per cluster, for each identified MNP and MN subtypes

```{r}
# Defining genes for MNPs and MN identification
gene1 <- "CHAT"
gene2 <- "ISL1"
gene3 <- "ISL2"
gene4 <- "MNX1"
gene5 <- "OLIG2"
gene6 <- "NEUROG2"

#List of genes for MN subtypes
gene7 <- "LHX3"
gene8 <- "FOXP1"
gene9 <- "HOXA5"
gene10 <- "POU3F1"
gene11 <- "PHOX2B"
gene12 <- "HOXB1"
gene13 <- "OTX2"
gene14 <- "MAFB"
gene15 <- "TSHZ1"
gene16 <- "PHOX2A"
gene17 <- "TBX20"

#Create a boolean list of cells expressing the gene of interest
MNP <- counts(sce.MN)[gene5, ]>0
MMC <- counts(sce.MN)[gene7, ]>0 & counts(sce.MN)[gene8, ]<1 
LMC <- counts(sce.MN)[gene8, ]>0 & counts(sce.MN)[gene7, ]<1 
HMC <- counts(sce.MN)[gene7, ]<1 & counts(sce.MN)[gene8, ]<1 & counts(sce.MN)[gene9, ]>0 
PMC <- counts(sce.MN)[gene7, ]<1 &  counts(sce.MN)[gene8, ]<1 & counts(sce.MN)[gene9, ]>0 & counts(sce.MN)[gene10, ]>0 | counts(sce.MN)[gene7, ]<1 &  counts(sce.MN)[gene8, ]<1 & counts(sce.MN)[gene9, ]>0 & counts(sce.MN)[gene15, ]>0 
SAC <- counts(sce.MN)[gene11, ]>0
OTX2 <- counts(sce.MN)[gene13, ]>1
PHOX2AB <- counts(sce.MN)[gene16, ]>1 | counts(sce.MN)[gene11, ]>1
#TBX20 <- counts(sce.MN)[gene17, ]>1 TBX20 is not expressed in the dataset
MAFBandHOXB1<- counts(sce.MN)[gene14, ]>4 & counts(sce.MN)[gene12, ]>3

#Remove cells without the gene
haveMNP <- sce.MN[ ,MNP]
haveMMC <- sce.MN[ ,MMC]
haveLMC <- sce.MN[ ,LMC]
haveHMC <- sce.MN[ ,HMC]
havePMC <- sce.MN[ ,PMC]
haveSAC <- sce.MN[ ,SAC]
haveOTX2 <- sce.MN[ ,OTX2]
havePHOX2AB <- sce.MN[ ,PHOX2AB]
haveMAFBandHOXB1 <- sce.MN[ ,MAFBandHOXB1]

#Print the number of cells expressing the gene of interest in eah cluster
summary(haveMNP$Cluster)
summary(haveMMC$Cluster)
summary(haveLMC$Cluster)
summary(haveHMC$Cluster)
summary(havePMC$Cluster)
summary(haveSAC$Cluster)
summary(haveOTX2$Cluster)
summary(havePHOX2AB$Cluster)
summary(haveMAFBandHOXB1$Cluster)

#Print the total number of cells in each cluster
summary(sce.MN$Cluster)

```

###16.5 Identifying subtypes of LMC MNs
We can identify cervical and lumbar LMC MNs based on their HOX genes expression profile

```{r}

# Defining genes to identify brachial LMC neurons 
gene18 <- "HOXA3"
gene19 <- "HOXA4"
gene20 <- "HOXC4"
gene21 <- "HOXA5"
gene22 <- "HOXC5"
gene23 <- "HOXA6"
gene24 <- "HOXC6" 
gene25 <- "HOXA7"
gene26 <- "HOXB7"
gene27 <- "HOXB8"
gene28 <- "HOXC8"
gene29 <- "ALDH1A2"
  
# Defining genes to identify lumbar LMC neurons
gene30 <- "HOXD8"
gene31 <- "HOXA9"
gene32 <- "HOXD9"
gene33 <- "HOXA10"
gene34 <- "HOXC10"
gene35 <- "HOXD10"
gene36 <- "HOXA11"
gene37 <- "HOXC11"
gene38 <- "HOXD11"
gene39 <- "LHX1"

#Create a boolean list of cells expressing the gene of interest
cervicalLMC <- counts(haveLMC)[gene23, ]>0 & counts(haveLMC)[gene29, ]>0 | counts(haveLMC)[gene24, ]>0 & counts(haveLMC)[gene29, ]>0 | counts(haveLMC)[gene23, ]>=1 | counts(haveLMC)[gene24, ]>=1 

RcervicalLMC <- counts(haveLMC)[gene23, ]>0 & counts(haveLMC)[gene29, ]>0 & counts(haveLMC)[gene21, ]>3 | counts(haveLMC)[gene23, ]>0 & counts(haveLMC)[gene29, ]>0 & counts(haveLMC)[gene22, ]>3 | counts(haveLMC)[gene24, ]>0 & counts(haveLMC)[gene29, ]>0 & counts(haveLMC)[gene21, ]>3 | counts(haveLMC)[gene24, ]>0 & counts(haveLMC)[gene29, ]>0 & counts(haveLMC)[gene22, ]>3

CcervicalLMC <- counts(haveLMC)[gene23, ]>0 & counts(haveLMC)[gene29, ]>0 & counts(haveLMC)[gene28, ]>3 | counts(haveLMC)[gene24, ]>0 & counts(haveLMC)[gene29, ]>0 & counts(haveLMC)[gene28, ]>3

lumbarLMC <-  counts(haveLMC)[gene23, ]<1 & counts(haveLMC)[gene24, ]<1 & counts(haveLMC)[gene29, ]<1 & counts(haveLMC)[gene21, ]<3 & counts(haveLMC)[gene22, ]<3 & counts(haveLMC)[gene28, ]<3 


#Remove cells without the gene
havecervicalLMC <- haveLMC[ ,cervicalLMC]
haveRcervicalLMC <- haveLMC[ ,RcervicalLMC]
haveCcervicalLMC <- haveLMC[ ,CcervicalLMC]
havelumbarLMC <- haveLMC[ ,lumbarLMC]

#Print the number of cells expressing the gene of interest in eah cluster
summary(haveLMC$Cluster)
summary(havecervicalLMC$Cluster)
summary(haveRcervicalLMC$Cluster)
summary(haveCcervicalLMC$Cluster)
summary(havelumbarLMC$Cluster)


```

###16.6 Identifying the lateral and the medial LMC neurons
Based on their expression of different HOX genes as well as their level of expression of ISL1, we can identify LMCl neurons, that will target the dorsal part of the limb, and LMCm neurons, that will target the ventral part of the limb (Dasen et al., 2005).

```{r}
#Create a boolean list of cells expressing the gene of interest
LMCl <-  counts(havecervicalLMC)[gene21, ]>0 & counts(havecervicalLMC)[gene39, ]>0  | counts(havecervicalLMC)[gene22, ]>0 & counts(havecervicalLMC)[gene39, ]>0 | counts(havecervicalLMC)[gene28, ]>0 & counts(havecervicalLMC)[gene39, ]>0

LMCm <-  counts(havecervicalLMC)[gene28, ]>0 & counts(havecervicalLMC)[gene2, ]>1

#Remove cells without the gene
haveLMCl <- havecervicalLMC[ ,LMCl]
haveLMCm <- havecervicalLMC[ ,LMCm]

#Print the number of cells expressing the gene of interest in eah cluster
summary(haveLMCl$Cluster)
summary(haveLMCm$Cluster)
```

###16.7 Colouring the t-SNE plot for cervical LMC MNs
Cervical LMC MNs are identified as LHX3-/FOXP1+/HOX6+/ALDH1A2+/HOXD8-/HOX9-

```{r}
sce.MN$cervicalLMC <- counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXA6",] >=1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXC6",] >=1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["HOXA6",] >2  & counts(sce.MN)["HOXD8",]<1 & counts(sce.MN)["HOXA9",]<1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["HOXC6",] >2 & counts(sce.MN)["HOXD8",]<1 & counts(sce.MN)["HOXA9",]<1
plotTSNE(sce.MN, colour_by = "cervicalLMC") +  ggtitle("tSNE-cervicalLMC MNs, Perplexity = 40") 
```

###16.8 Colouring the t-SNE plot for HOXC8 cervical LMC MNs = cauda-most cervical LMC
The caudal-most cervical LMC MNs are identified as LHX3-/FOXP1+/HOX6+/ALDH1A2+/HOXC8+

```{r}
sce.MN$CcervicalLMC <- counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXA6",] >=1 & counts(sce.MN)["HOXA5",]>=1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXC6",] >=1 & counts(sce.MN)["HOXA5",]>=1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXA6",] >=1 & counts(sce.MN)["HOXC5",]>=1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXC6",] >=1 & counts(sce.MN)["HOXC5",]>=1 

plotTSNE(sce.MN, colour_by = "CbrachialLMC") +  ggtitle("tSNE-CaudalBrachialLMC MNs, Perplexity = 40") 
```

###16.9 Colouring the t-SNE plot for HOX5+ cervical LMC MNs = rostral-most cervical LMC
The rostral-most cervical LMC MNs are identified as LHX3-/FOXP1+/HOX6+/ALDH1A2+/HOX5+

```{r}
sce.MN$RcervicalLMC <- counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXA6",] >=1 & counts(sce.MN)["HOXA5",]>1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXA6",] >=1 & counts(sce.MN)["HOXC5",]>1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXC6",] >=1 & counts(sce.MN)["HOXA5",]>1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["ALDH1A2",] >=1 & counts(sce.MN)["HOXC6",] >=1 & counts(sce.MN)["HOXC5",]>1

plotTSNE(sce.MN, colour_by = "RcervicalLMC") +  ggtitle("tSNE-RcervicalLMC MNs, Perplexity = 40") 
```

###16.10 Colouring the t-SNE plot for lumbar LMC MNs
Lumbar LMC MNs are identified as LHX3-/FOXP1+/HOX6-/ALDH1A2+/HOX5-/HOD8+/HOX9+

```{r}
sce.MN$LumbarLMC <- counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["HOXA6",]<1 & counts(sce.MN)["HOXC6",] <1 & counts(sce.MN)["HOXA5",]<1 & counts(sce.MN)["HOXC5",]<1 & counts(sce.MN)["ALDH1A2",]>=1 & counts(sce.MN)["HOXD8",]>=1 | counts(sce.MN)["LHX3",] <1 & counts(sce.MN)["FOXP1",]>=1 & counts(sce.MN)["HOXA6",]<1 & counts(sce.MN)["HOXC6",] <1 & counts(sce.MN)["HOXA5",]<1 & counts(sce.MN)["HOXC5",]<1 & counts(sce.MN)["ALDH1A2",]>=1 & counts(sce.MN)["HOXA9",]>=1

plotTSNE(sce.MN, colour_by = "LumbarLMC") +  ggtitle("tSNE-LumbarLMC MNs, Perplexity = 40") 
```

###16.11 Identifying different maturation states in the LMC population
Newly-born LMC MNs co-express ISL1/2 while later born LMC MNs down-regulate ISL1 to the profit of LHX1 (Dasen et al., 2005).

```{r}

#Create a boolean list of cells expressing the gene of interest
newLMC <- counts(haveLMC)[gene2, ]>2 & counts(haveLMC)[gene39, ]<=2
matureLMC <- counts(haveLMC)[gene39, ]>2 & counts(haveLMC)[gene2, ]<=2 

#Remove cells without the gene
havenewLMC <- haveLMC[ ,newLMC]
havematureLMC <- haveLMC[ ,matureLMC]

#Print the number of cells expressing the gene of interest in eah cluster
summary(havenewLMC$Cluster)
summary(havematureLMC$Cluster)

#Print the total number of cells in each cluster
summary(haveLMC$Cluster)

```

###16.12 Colouring tSNE for ISL1 expression level

```{r}
plotTSNE(sce.MN, colour_by = "ISL1") +  ggtitle("tSNE-ISL1 expression level, Perplexity = 40") 

```
###16.13 Colouring tSNE for LHX1 expression level

```{r}
plotTSNE(sce.MN, colour_by = "LHX1") +  ggtitle("tSNE-LHX1 expression level, Perplexity = 40") 

```

```{r}
# Clear the workspace
rm(list = ls())
```

##**17 DETECTING MARKER GENES BETWEEN SUBPOPULATIONS**
Identifying genes that are consistently differentially expressed (DE) in one subpopulation compared to the others. DE testing can be performed with the edgeR package (Robinson et al. 2010).

###17.1 Setting up a design matrix specifying which cells belong to each cluster
*Note: clusters were defined in #15-"Clustering"

```{r}
library(limma)
library(edgeR)

# Load previous object (if using the same dataset)
library(scran)
library(scater)
load("/Users/louise/Documents/R workflow/Objects/sce.MN_clusters")

#Set up a design matrix
cluster <- factor(sce.MN$Cluster)
de.design <- model.matrix(~0 + cluster)
head(colnames(de.design))
```

###17.2 Setting up a DGElist object for entry into the edgeR analysis

```{r}
DEG.list <- convertTo(sce.MN, type="edgeR") # This new object contains all relevant information from the original sce object.

# edgeR uses negative binomial (NB) distributions to model the read/UMI counts for each sample. We estimate the NB dispersion parameter that quantifies the biological variability in expression across cells in the same cluster. Large dispersion estimates above 0.5 are often observed in scRNA-seq data due to technical noise (in contrast to bulk data where values of 0.05-0.2 are more typical). We then use the design matrix to fit a NB GLM to the counts for each gene (McCarthy et al. 2012).
DEG.list <- estimateDisp(DEG.list, de.design)
fit <- glmQLFit(DEG.list, de.design, robust=TRUE)
summary(DEG.list$tagwise.dispersion)
```

###17.3 Identification of all DE genes between each cluster

```{r}
# We assume that each cluster corresponds to one or two specific subpopulations (LMC MNs or HMC MNs for example). Each gene is tested for DE between the chosen cluster and every other cluster in the dataset. The same process can be applied to any cluster by changing "chosen.clust"
result.logFC <- result.PValue <- list()
chosen.clust <- which (levels(cluster)=="1") #character as "cluster" is a factor
for (clust in seq_len(nlevels(cluster))) {
  if (clust==chosen.clust) {next}
  contrast <- numeric(ncol(de.design))
  contrast [chosen.clust] <- 1
  contrast [clust] <- -1
  res <- glmQLFTest(fit, contrast=contrast) # This will make pairwise comparisons between the chosen cluster and all others.
  con.name <- paste0('vs.', levels(cluster)[clust])
  result.logFC[[con.name]] <- res$table$logFC
  result.PValue [[con.name]] <- res$table$PValue
}
```

###17.4 Potential marker genes identification

```{r}
# Potential marker genes are identified by taking the top DE genes from each pairwise comparison between clusters. We arrange the results into a single output table that allows a marker set to be easily defined for a specifized size of the top set. 
collected.ranks <- lapply(result.PValue, rank, ties="first")
min.rank <- do.call(pmin, collected.ranks)
marker.set <- data.frame(Top=min.rank, Gene=rownames(DEG.list), logFC=do.call(cbind, result.logFC), stringsAsFactors=FALSE)
marker.set <- marker.set[order(marker.set$Top),]

head(marker.set, 5)
```

###17.5 Saving the list of candidate marker genes for further examination
If most of the top markers have strong and consistent up- or downregulation in cells of cluster N compared to some or all of the other clusters, than cells from cluster N can be identified as those that express the upregulated markers and do not express the downregulated markers.

```{r}
#remove any duplicates
marker.set<- unique(marker.set)

sce.hm.unique <- unique(sce.MN$Barcode)
sce.MN.hm <- sce.MN[ , sce.hm.unique]

write.table(marker.set, file="/Users/louise/Documents/R workflow/ToSave/_5markerCcluster1",sep="\t", col.names=NA, quote=FALSE)

top.markers <- marker.set$Gene [marker.set$Top <= 5]

# We also examine their expression profiles to verify that the DE signature is robust
plotHeatmap(sce.MN.hm, features=top.markers, exprs_values="logcounts", cellheight = 9,
    zlim=NULL, center=TRUE, symmetric=TRUE,cluster_col=FALSE,
    colour_columns_by="Cluster", columns=order(sce.MN.hm$Cluster), main= paste("5MostDEGs Cluster 1 Heatmap"), fontsize_row = 5, fontsize_col = 0.2, treeheight_col = 10)
```

##**18 GENE ONTOLOGY ANALYSIS WITH goseq**

```{r}
library(goseq)
# We use p.adjust() to convert P-values to FDR (p-values corrected for multiple hypothesis tests) since goseq does not do this internally. Then, Format the DEG list (topTags output from edgeR) into a vector suitable for goseq() - a vector of all DEGs where sig genes are marked "1" and others are marked "0"
genes=as.integer(p.adjust(res$table$PValue[res$table$logFC!=0],method="BH")<.05)
names(genes)=row.names(res$table[res$table$logFC!=0,])
table(genes)

# We use the hg19 build of the human genome, which in goseq() has gene ID formats for ENSEMBL IDs ("ensGene"), Entrez IDs ("knownGene") and gene symbols ("geneSymbol"). Full list of supported organisms can be viewed by running supportedOrganisms(). Using supported gene ID formats allows goseq() to automatically fetch GO terms, as well as normalize for gene length bias.

#Saving the DEGs list and the number of DEGs.
write.table(genes, file="/Users/louise/Documents/R workflow/ToSave/GOseq-Cluster1 DEGs", sep="\t", quote=FALSE, col.names=NA, row.names=TRUE)
write.table(table(genes), file="/Users/louise/Documents/R workflow/ToSave/GOseq-Cluster1 #ofDEGs", sep="\t", quote=FALSE, col.names=NA, row.names=TRUE)
```

###18.1 Fitting the probability weighting function

```{r}
# This gives the probability that a gene would be considered differentially expressed based on its gene length alone
pwf=nullp(genes,"hg19", "geneSymbol")
GO.wall=goseq(pwf, "hg19", "geneSymbol") 

#Extract the GO terms that are enriched above 0.05 FDR cutoff (Benjamini and Hochberg 1995)
enriched.GO=GO.wall[p.adjust(GO.wall$over_represented_pvalue,method="BH")<.05,]
```

###18.2 Identifying the enriched GO terms in the chosen cluster

```{r}
# How many molecular functions (MF), biological proceeses (BP), and cellular component (CC) terms are significantly enriched in the sig DEGs compared to the other genes?
NROW(which(enriched.GO$ontology=="MF"))
NROW(which(enriched.GO$ontology=="CC"))
NROW(which(enriched.GO$ontology=="BP"))
```

```{r}
# What are the GO terms that are significantly enriched?
goseq_CC <- enriched.GO[enriched.GO$ontology=="CC",]
goseq_CC
goseq_MF <- enriched.GO[enriched.GO$ontology=="MF",]
goseq_MF
goseq_BP <- enriched.GO[enriched.GO$ontology=="BP",]
goseq_BP
```

```{r}
# Extracting interesting terms from BP category and ordering by enrichment in DEGs
BPtermsofinterest <- c(grep("neur.*", enriched.GO$term, value=TRUE), grep("diff.*", enriched.GO$term, value=TRUE), grep("motor.*", enriched.GO$term, value=TRUE), grep("dev.*", enriched.GO$term, value=TRUE), grep("fate.*", enriched.GO$term, value=TRUE), grep("prolif.*", enriched.GO$term, value=TRUE),grep("pattern.*", enriched.GO$term, value=TRUE),grep("spinal.*", enriched.GO$term, value=TRUE),grep("cycle.*", enriched.GO$term, value=TRUE),grep("interneur.*", enriched.GO$term, value=TRUE),grep("muscle.*", enriched.GO$term, value=TRUE))
goseq_BPtermsofinterest <- goseq_BP[goseq_BP$term %in% BPtermsofinterest,]
goseq_BPtermsofinterest
goseq_MFtermsofinterest <- goseq_MF[goseq_MF$term %in% BPtermsofinterest,]
goseq_MFtermsofinterest
```

```{r}
# Clear the workspace
rm(list = ls())
```
